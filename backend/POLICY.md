## 백엔드 정책 및 기술개요 설명

### 1. 예상별점 추천

#### (1) 개요
 - 유저와 비슷한 성향을 가진 다른 유저가 긍정적으로 평가한 관광지를 추천해줌으로써 특정 관광지에 대한 유저의 평가를 예측하여 높은 만족도를 제공하고자 함

#### (2) 문제해결 방법 : 피어슨 상관계수
 - 콜라보레이티브 필터링 기법(일명 CF 알고리즘 이라고 칭한다) 중 피어슨 상관계수 방법을 사용하였다.
 - 피어슨 상관계수란 두 배열이 주어졌을 때, 두 배열간의 상관 관계, 유사성을 계량화한 수치를 의미한다.
 - 피어슨 상관계수는 -1 ~ 1사이의 결과값을 반환하며, 1은 완벽한 양의 선형 상관 관계, 0은 선형 상관 관계 없음, -1은 완벽한 음의 상관 관계(두 배열이 반대의 성향을 가진다고 판단할 수 있음)를 의미한다

#### (3) 비즈니스 로직
 - 유저A가 그동안 평가해온 별점 데이터로 배열A를 만든다. [5, 3, 1, 1, 3, 5]
 - 사용자에게 표시 될 관광지 Z에 대해 평가한 사용자들의 별점 평가 데이터를 가져온다. 그리고 그것들을 배열A와 마찬가지로 배열 B, C, D ... 로 만든다.
 - 이때 배열 A~D의 각 인덱스값 끼리는 서로 동일한 관광지를 의미한다. 예를들어 배열A~E의 모든 0번째 인덱스는 남한산성에 대한 평가, 1번째 인덱스는 수원 행궁에 대한 평가.. (☆ 이해가 안된다면 담당자에게 꼭 물어봐서 이해하도록 하자)
 - A와 B, A와 C, A와 D 각각에 대해 피어슨 상관계수를 측정한다.
 - (☆ 바로 윗 단계를 위해 가입초기에 가보았을 법한 관광지에 대한 별점평가를 입력받는 것이다. 이 과정이 없었다면 두 배열간 겹쳐지는 관광지가 충분히 존재하지 않아 애초에 적합한 배열을 생성하기조차 어려웠을 것이다. 이 부분이 이해가 안된다면 담당자에게 자세히 다시 질문하거나 공부를 하도록하자)
 - 각각의 결과를 B' = 0.9, C' = 0.1, D' = -0.7라 칭하자. 이 세 결과 중 가장 높은 유사성을 가진 조합을 찾는다.
 - 가장 높은 유사성은 B'이므로 유저 B가 유저 A와 가장 유사성이 높은 사용자라 평가하고, B가 관광지 Z에 대해 평가한 점수를 A의 예상 별점으로 제공한다.
 - 위 과정을 현재 유저A의 위치 기준으로 표시 되어야 할 모든 관광지에 대해 실시한다.

### 2. MBTI 추천
 - 관광지 Z에 대해 평가한 사람들의 MBTI 종류에는 INTJ, ENFP, ISTJ가 있다고 가정하자.
 - 위 세가지 MBTI 유형별로 평균적으로 별점을 얼마나 부여했는지 계산한다.
 - INTJ = 4.5, ENFP = 2.1, ISTJ = 3.3
 - INTJ들이 관광지 Z에 대해 가장 높은 평균점수가 나왔다.
 - 그러므로, 관광지 Z는 INTJ인 유저들에게 MBTI 추천 관광지로 소개된다.

### 3. 관광지 취향(인상) 추천
 - 유저 A는 가입할 때 입력했던 취향(인상)이 "활기있는", "모험적인"이다.
 - 관광지 X는 유저들로부터 평가를 받았을 때의 취향(인상)을 요약해보자면 "활기있는", "자연친화적인"을 받았다.
 - 관광지 Y는 "조용한", "차분한"을 받았다.
 - 유저 A의 지도에 관광지 X, Y가 표시 될 때, 유저A는 "활기있는" 취향을 갖고있고 관광지 X도 "활기있는" 평가를 받았으므로 취향(인상) 추천 대상에 포함된다.
 - 관광지 Y가 평가받은 "조용한", "차분한"은 유저 A가 입력했던 취향이 아니므로 취향(인상) 추천 대상이 아니다.

### 4. 코스 추천
 - 각 카테고리 별로(관광지, 쇼핑, 음식점) 예상별점이 제일 높은 것을 추려낸다.
 - 추려낸 3~4개의 지역을 프론트단 지도상으로 이어주며 보여주며 키로수 거리를 제공한다.

### 5. Supporter 시스템
 - 위 1~4번 항목들을 모두 꼼꼼히 읽어보았다면 우리 서비스는 사람들이 평가를 많이 할 수록 서비스의 품질이 좋아진다는 것을 알 수 있을 것이다. (이유 설명 가능해야 함)
 - 하지만 우리서비스는 프로토타입 수준인 만큼, 사용자수가 0에 가깝다.
 - 이에 따라 원활한 시연을 위해 임의의 더미유저들을 넣기로하였으며 이에 대한 정책은 다음과 같다.
 - 유저 A가 앱을 켜서 현재 기반으로 관광지들을 추천받는 순간,
 - 당연히 추천받은 관광지에는 평가한 데이터들이 아무것도 없을 것이다.
 - 관광지Z에 대해 아무런 평가가 없다면 Z에 대한 사용자A의 별점 예측도 불가능해지고 MBTI 추천도 불가능해지고, 취향(인상) 추천도 불가능해 진다.
 - 이를 방지하고자 주변 관광지를 공공데이터API로 조회한 후, 조회된 모든 관광지에 대해 임의의 더미유저들이 랜덤으로 이 관광지에 대해 평가하는 일명 Supporter system을 만들었다.
 - 관광지Z에 대해 임의의 유저 B~E가 별점도 랜덤으로 넣어주고, 취향(인상)도 어떤 곳인지 평가해준다.
 - 랜덤값이긴하지만 어쨌든 실존하는 사람들이 이렇게 평가를 했다고 가정한다면, 평가데이터들이 존재하므로, 유저 A에게는 이 데이터들을 기반으로 추천을 해줄 수 있게된다.
 - 랜덤이다보니 시연시 변수가 생길 수 있으므로.. 충분한 시연에 대한 사전 테스트가 필수이다.
 - 에러가 발생하지 않도록 사전에 준비를 잘 하도록 하자..
 - Supporter시스템은 OpenAPIService.java에 supporter() 메소드를 참고하자. 복잡한 소스가 아니니 어떤식으로 평가를 해주고있나 구경해보면 도움이 될 것이다.

----

## 예상 질문

### 1. 왜 가입할 때 평가데이터를 받고 있나요?

 - 당근여행은 사용자들의 평가데이터를 기반으로 성향분석을 통해 맞춤 관광지를 추천해주는 시스템 입니다.
 - 기술적인 용어로는 콜라보 레이티브 필터링(협업필터링)이라 하는데요, 여러 상용 서비스에서도 이러한 방식을 채택하여 알고리즘 추천을 하고 있으며(EX. 왓챠)
 - 사용자에게 보다 정확하고 유익한 추천을 주기 위해 사전에 평가데이터를 받고 있습니다.

### 2. 앞으로의 개선점은?

 - 사용자의 평가가 많아질수록 정확해지는 구조이기 때문에 평가가 부족한 관광지에 대해서는 상대적으로 정확하지 않은 추천을 해줄 가능성이 있습니다. 이에 따라 보정에 대한 기술적인 고민을 더 해볼 예정입니다.


----

## 우리들의 고민

### 1. 시연 시 정해진 시나리오대로 결과 화면이 나오도록 하려면??


